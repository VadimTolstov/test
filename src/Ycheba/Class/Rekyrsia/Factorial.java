package Ycheba.Class.Rekyrsia;

// Простой пример рекурсии
class Factorial {
    // Рекурсивный метод
    int factR(int n) {
        int result;
        if (n == 1) return 1;
        result = factR(n - 1) * n;//Рекурсивный вызов метода factR ()
        System.out.println(result);
        return result;
    }

    /* для n=4 factR(4)  сначало считает    |  потом начинает подниматься с низу в верх и умножать на n
           4* factR(3) в скобках рекрусию и |  4* 6=24// от тройки вернулась шестерка и умнажаем ее на 4
           3* factR(2)  спускается в низ    |  3* 2=6 // от двойки вернулась двойк умножаем на три
           2* factR(1)                      |  2* 1=2 // двойку умножели на вернувшиюся еденицу
           factR(1) = return 1;закончели  на|  factR(1) = return 1;
                             условии return


     */
    // Вариант программы, вычисляющий факториал
    // итеративным способом
    int factl(int n) {
        int t, result;
        result = 1;
        for (t = 1; t <= n; t++) result *= t;
        return result;
    }
}

class Recursion {
    public static void main(String args[]) {
        Factorial f = new Factorial();
        System.out.println("Вычисление рекурсивным методом");
        System.out.println("Факториал 3 равен " + f.factR(3));
        System.out.println("Факториал 4 равен " + f.factR(4));
        System.out.println("Факториал 5 равен " + f.factR(5));
        System.out.println();

        System.out.println("Вычисление итеративным методом");
        System.out.println("Факториал 3 равен " + f.factl(3));
        System.out.println("Факториал 4 равен " + f.factl(4));
        System.out.println("Факториал 5 равен " + f.factl(5));
    }
}
/*Рекурсивные варианты многих процедур могут выполняться немного медленнее, чем их итерационные эквиваленты, из-за дополнительных затрат
246 Java: руководство для начинающих, 7-е издание
системных ресурсов на неоднократные вызовы метода. Если же таких вызовов
окажется слишком много, то в конечном итоге системный стек может быть переполнен. А поскольку параметры и локальные переменные рекурсивного метода хранятся в системном стеке и при каждом очередном вызове этого метода
создается их новая копия, то в какой-то момент стек может оказаться исчерпанным. Если возникнет подобная ситуация, исполняющая среда Java сгенерирует
исключение. Но в большинстве случаев об этом не стоит особо беспокоиться.
Как правило, переполнение системного стека происходит тогда, когда рекурсивный метод выходит из-под контроля.
Главное преимущество рекурсии заключается в том, что она позволяет реализовать некоторые алгоритмы яснее и проще, чем итерационным способом. Например, алгоритм быстрой сортировки довольно трудно реализовать итерационным способом. А некоторые задачи, например, искусственного интеллекта,
очевидно, требуют именно рекурсивного решения. При написании рекурсивных методов следует указать в соответствующем месте условную инструкцию,
например if , чтобы организовать возврат из метода без рекурсии. В противном случае возврат из вызванного однажды рекурсивного метода может вообще не произойти. Подобного рода ошибка весьма характерна для реализации
рекурсии в практике программирования. Поэтому рекомендуется пользоваться инструкциями, содержащими вызовы метода p r i n t l n (), чтобы следить за
происходящим в рекурсивном методе и прервать его выполнение, если в нем
обнаружится ошибка.
*/